\documentclass[a4paper,10pt,notitlepage]{scrreprt}

\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{setspace}
\usepackage{subfig}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{fixltx2e}
\usepackage{multirow}
\usepackage{array}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{subfig}
\usepackage{nomencl}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage{natbib}
% \usepackage{makeidx}
\usepackage{nicefrac}
\usepackage{bbold}

\captionsetup{labelfont=footnotesize,textfont=footnotesize}

\newcolumntype{x}[1]{>{\begin{flushleft}$}p{#1}<{$\end{flushleft}}}
\newcolumntype{y}[1]{>{\begin{center}$}p{#1}<{$\end{center}}}
\newcolumntype{z}[1]{>{\begin{flushright}$}p{#1}<{$\end{flushright}}}
\newcolumntype{m}{>{$}l<{$}}
\newcolumntype{n}{>{$}c<{$}}
\newcolumntype{o}{>{$}r<{$}}

\bibliographystyle{plain}

% Title Page
\title{Scientific Visualization\\Project II}
\author{Milian Wolff}


\begin{document}
\maketitle

\begin{abstract}
Our second project in the scientific visualization class by Eugene Zhang gave
us the opportunity to get acquainted with the algorithms behind ``pen-and-ink
sketching'' of a 3D mesh surface. First we explore the steps required to
visualize silhouettes of a geometry. Then we calculate the vertex-based
curvature and curvature tensors. Finally we will combine the both to draw a
sketch-like version of a given geometry.

The source code of my exercise solutions can be found online under

\begin{center}\url{https://github.com/milianw/scivi}\end{center}
\end{abstract}

\begingroup
\let\clearpage\relax

\tableofcontents
\endgroup

\chapter{Corner Table}

As a foundation for the later tasks we first had to implement a corner table. I
did this by following the steps outlined in class:

\begin{itemize}
 \item iterate over all triangles
 \item add each corner in the triangle to a table
 \item sort table by $min(c.prev.vertex, c.next.vertex)$ and
$max(c.prev.vertex, c.next.vertex)$
 \item iterate over sorted table and associate consecutive rows with equal
$min$ and $max$ entries as opposite corners
\end{itemize}

The implementation can be found in \texttt{CornerTable.java}.

The resulting corner table is essentially a linked list which is straight
forward to use. I additionally added a \texttt{Corner[] vertexNeighbors()}
method to my \texttt{Corner} object, which essentially returns the $N^1$-ring
vertex neighbors.

\section{Validation}

To verify the correctness of my implementation of a corner table, I wrote
\texttt{Ex2\_1.java}. When started, the user defines a geometry. Then the corner
table for said geometry is computed. Now we iterate over each corner \texttt{c}
and run a set of assertion-based tests in each step:

\begin{itemize}
 \item \texttt{c.next != null}
 \item \texttt{c.prev != null}
 \item \texttt{c.next.triangle != c.triangle}
 \item \texttt{c.prev.triangle != c.triangle}
\end{itemize}

Furthermore, the correctness of the ``opposite''-association is validated by
asserting the following tests:

\begin{itemize}
 \item \texttt{c.triangle != c.opposite.triangle}
 \item \texttt{c.next.vertex == c.opposite.prev.vertex}
 \item \texttt{c.prev.vertex == c.opposite.next.vertex}
 \item \texttt{c == c.opposite.opposite}
 \item \texttt{c.prev.opposite.next.vertex == c.next.vertex}
 \item \texttt{c.prev.opposite != c.next}
 \item \texttt{c.prev.opposite.prev.vertex == c.vertex}
 \item \texttt{c.prev.opposite.prev != c}
 \item \texttt{c.next.opposite.prev.vertex == c.prev.vertex}
 \item \texttt{c.next.opposite.prev != c.prev}
 \item \texttt{c.next.opposite.next.vertex == c.vertex}
 \item \texttt{c.next.opposite.next != c}
\end{itemize}

Keep in mind though that in open surfaces like e.g. \texttt{Gauss\_3042.byu} not
every corner can be associated to an opposite one. This is handled gracefully in
my corner table implementation and unit tests.

Another implicit verification of my implication lies in the extensive usage of
the corner table in the following exercises. Since the solutions there seem to
be visually correct, the corner table seems to yield correct results.

\chapter{Silhouette}

Now we want to find the silhouette of a 3D geometry using two different
algorithsm. My solutions to both can be found in \texttt{Silhouette.java} and
\texttt{Ex2\_2.java}.

\section{Face-based approach}

The first task was to find the silhouette by iterating over all edges and
finding those, where only one of the adjacent triangles is ``visible''. Here, we
consider a triangle $T$ to be visible when

\begin{equation}
 (\vec{c}_T - \vec{v}) \cdot \vec{n}_T < 0,
\end{equation}

with $\vec{c}_T$ being the center and $\vec{n}_T$ being the normal of the
triangle respectively. $\vec{v}$ is the position of the viewer.

Note that this approach yields undefined results for triangles that are
exactly perpendicular to the view ray. There, the dot product will be zero and
the triangle is either an invisible backside or a visible frontside. I ignore
these edges, assuming that this case only happens for faces somewhere in the
middle of the (in-)visible surface and are thus not part of the silhouette
anyways.

Now to actually find the silhouette, I first iterate over all triangles and
store the associated index to a list $L$ when the triangle is visible. Then
I iterate over the corner table and find corners $c$ within a visible triangle,
i.e. $c.triangle$ is contained in $L$. Then the edge between $c.prev.vertex$
and $c.next.vertex$ is part of the silhouette, if either $c.opposite$ is
undefined, or alternatively $c.opposite.triangle$ is not contained in $L$.

My implementation of the above can be found in
\texttt{Silhouette.createFaceBasedSilhouette()}.

\subsection{Problems}

The silhouette is view dependendend and \texttt{Ex2\_2} hence recalculates the
silhouette whenever the view point changes. Now when rotating a given geometry,
the main problem of this approach becomes apparent: Gradual changes in the view
can have a big difference one the silhouette. Comparing e.g. fig.
\ref{fig:face-silhouette-bunny-1} and \ref{fig:face-silhouette-bunny-2} shows
this issue at the right ear. Additionally we also see three artifacts, two on
the body and one at the left eye.

The same issue is also responsible for the jagged edge of the sphere silhouette
as visible in fig. \ref{fig:face-silhouette-sphere}. 

\begin{figure}
  \subfloat[]{
    \label{fig:face-silhouette-bunny-1}
    \includegraphics[scale=0.4]{img-2-2/bunny-1.eps}}
  \subfloat[]{
    \label{fig:face-silhouette-bunny-2}
    \includegraphics[scale=0.4]{img-2-2/bunny-2.eps}}
 \caption{Face-based silhouette of the bunny under slight rotation}
 \label{fig:face-silhouette-bunny}
\end{figure}

\section{Vertex-based approach / zero level set}

In an attempt to fix the issues of our first approach, we now apply a different
scheme that computes the so called zero level set. That is the curve on the
surface where the dot product between the curve normal and the view ray is
always zero.

To compute this curve we iterate over the corner table and calculate the dot
product between the view ray and the normal at the corner vertex $c$ and its
previous and next vertex $p$ and $n$:

\begin{eqnarray}
 d_{c} = a = (\vec{c} - \vec{v}) \cdot \vec{n}_c \\
 d_{p} = b = (\vec{p} - \vec{v}) \cdot \vec{n}_p \\
 d_{n} = c = (\vec{n} - \vec{v}) \cdot \vec{n}_n
\end{eqnarray}

If we then encounter a triangle where either $a \leq 0$, $b \geq 0$ and $c \geq
0$ or $a \geq 0$, $b \leq 0$ and $c \leq 0$, then a zero level set line goes
through this triangle. We assume it can be approximated
linearly interpolating $a$ and $b$ onto the edge between $c$ and $p$ and
analogously for $a$ and $c$ and then connecting the two points for which the
interpolated dot product should yield zero.

The code for my implementation can be found in
\texttt{Silhouette.createVertexBasedSilhouette()} and
\texttt{Silhouette.findZeroLevel()}.

\subsection{Comparison}

The vertex-based silhouette yields mostly better results, as can be seen in
e.g. figs. \ref{fig:silhouette-sphere}, \ref{fig:silhouette-dragon},
\ref{fig:face-silhouette-feline} or \ref{fig:face-silhouette-buddha}.

Personally I find the comparison between the two algorithms as
applied to the dragon in fig. \ref{fig:silhouette-dragon} and the feline in fig.
\ref{fig:face-silhouette-feline} the most interesting. While in both cases, the
vertex-based approach yields subjectively more correct silhouettes, the
face-based approach yields a visually more pleasing result for the silhouette
in fig. \ref{fig:face-silhouette-feline}. Here the rendering artifacts, that
look bad in the dragon, actually make the image more detailed and hence more
similar to an actual ``pen-and-ink'' scetch. The same happens for the buddha in
\ref{fig:face-silhouette-buddha}.

\begin{figure}
  \subfloat[face-based]{
    \label{fig:face-silhouette-sphere}
    \includegraphics[scale=0.4]{img-2-2/sphere-face.eps}}
  \subfloat[vertex-based]{
    \label{fig:vertex-silhouette-sphere}
    \includegraphics[scale=0.4]{img-2-2/sphere-vertex.eps}}
 \caption{Comparison of face- and vertex-based silhouette for the sphere}
 \label{fig:silhouette-sphere}
\end{figure}

\begin{figure}
  \subfloat[face-based]{
    \label{fig:face-silhouette-dragon}
    \includegraphics[scale=0.4]{img-2-2/dragon-face.eps}}
  \subfloat[vertex-based]{
    \label{fig:vertex-silhouette-dragon}
    \includegraphics[scale=0.4]{img-2-2/dragon-vertex.eps}}
 \caption{Comparison of face- and vertex-based silhouette for the dragon}
 \label{fig:silhouette-dragon}
\end{figure}

\begin{figure}
  \subfloat[face-based]{
    \label{fig:face-silhouette-feline}
    \includegraphics[scale=0.4]{img-2-2/feline-face.eps}}
  \subfloat[vertex-based]{
    \label{fig:vertex-silhouette-feline}
    \includegraphics[scale=0.4]{img-2-2/feline-vertex.eps}}
 \caption{Comparison of face- and vertex-based silhouette for the feline}
 \label{fig:silhouette-feline}
\end{figure}

\begin{figure}
  \subfloat[face-based]{
    \label{fig:face-silhouette-buddha}
    \includegraphics[scale=0.4]{img-2-2/buddha-face.eps}}
  \subfloat[vertex-based]{
    \label{fig:vertex-silhouette-feline}
    \includegraphics[scale=0.4]{img-2-2/buddha-vertex.eps}}
 \caption{Comparison of face- and vertex-based silhouette for the buddha}
 \label{fig:silhouette-buddha}
\end{figure}

\section{Features}

As I just layed out, the silhouette is only one part of an actual painting,
albeit a very important one. Generally though, an object has other important
features, like e.g. the face of the buddha which is completely bare when viewed
up-front in fig. \ref{fig:silhouette-buddha}. As we learned in class this can
be handled by additionally taking ridges and valleys into account. Especially
the apparent ridges algorithm shown in class should yield good results when
applied to the buddha geometry.

For feature-less objects though, like e.g. the sphere, the ridges and
valleys approach will not yield any good results. Here we should rather apply
an algorithm that takes lightning and curvature into account, like we do later
on in the last exercise.

\section{Silhouette in JavaView}

To actually draw the silhouette in JavaView, one has to add the edges to a
\texttt{PgPolygonSet} using \texttt{addPolygon()}. Furthermore we must prevent
painting of obscured parts of the silhouette, which can be achieved by
keeping the original geometry in the display but coloring its elements
completely white using \texttt{PgElementSet.setGlobalElementColor(Color.white)}
and by disabling lightning via
\texttt{PvDisplayIf.setLightingModel(PvLightIf.MODEL\_SURFACE)}.

\chapter{Curvature estimation}

TODO: paper source



% \bibliography{sources}

\end{document}

% kate: replace-tabs on;